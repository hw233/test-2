#coding:utf8
"""
Created on 2015-10-27
@Author: jiangtaoran(jiangtaoran@ice-time.cn)
@Brief : 采集相关请求处理逻辑
"""

from utils import logger
from utils.timer import Timer
from utils.ret import Ret
from proto import exploitation_pb2
from datalib.global_data import DataBase
from app import pack
from app import compare
from app import log_formater
from app.data.hero import HeroInfo
from app.data.node import NodeInfo
from app.business import mail as mail_business
from app.business import building as building_business
from app.business import exploitation as exploitation_business


OFFLINE_EXPLOIT_TIME_1 = 14400
OFFLINE_EXPLOIT_TIME_2 = 28800
OFFLINE_EXPLOIT_TIME_3 = 43200


class ExploitationProcessor(object):

    def gather(self, user_id, request):
        """在关键节点上进行采集
        """
        timer = Timer(user_id)

        req = exploitation_pb2.GatherReq()
        req.ParseFromString(request)

        defer = DataBase().get_data(user_id)
        defer.addCallback(self._calc_gather, req, timer)
        defer.addErrback(self._gather_failed, req, timer)
        return defer


    def _calc_gather(self, data, req, timer):
        """采集逻辑
        """
        nodes = []
        new_items = []

        for node_proto in req.nodes:
            node_basic_id = node_proto.basic_id
            node_id = NodeInfo.generate_id(data.id, node_basic_id)
            node = data.node_list.get(node_id)
            nodes.append(node)

        if not exploitation_business.gather(data, nodes, new_items, timer.now):
            raise Exception("Gather failed")

        res = self._pack_gather_response(data.resource.get(True), new_items, timer.now)

        defer = DataBase().commit(data)
        defer.addCallback(self._gather_succeed, req, res, timer)
        return defer


    def _pack_gather_response(self, resource, new_items, now):
        """打包采集返回
        """
        res = exploitation_pb2.GatherRes()
        res.status = 0
        pack.pack_resource_info(resource, res.resource)
        for (basic_id, num) in new_items:
            message_item = res.items.add()
            message_item.basic_id = basic_id
            message_item.num = num
        return res


    def _gather_succeed(self, data, req, res, timer):
        """采集成功
        """
        response = res.SerializeToString()
        log = log_formater.output(data, "Gather succeed", req, res, timer.count_ms())
        logger.notice(log)
        return response


    def _gather_failed(self, err, req, timer):
        """采集失败
        """
        logger.fatal("Gather failed[reason=%s]" % err)
        res = exploitation_pb2.GatherRes()
        res.status = -1
        response = res.SerializeToString()
        logger.notice("Gather failed[user_id=%d][req=%s][res=%s][consume=%d]" %
                (timer.id, req, res, timer.count_ms()))
        return response


    def start_exploit(self, user_id, request):
        """开始开采
        """
        timer = Timer(user_id)

        req = exploitation_pb2.ExploitReq()
        req.ParseFromString(request)

        defer = DataBase().get_data(user_id)
        defer.addCallback(self._calc_start_exploit, req, timer)
        defer.addCallback(self._start_exploit_succeed, req, timer)
        defer.addErrback(self._start_exploit_failed, req, timer)
        return defer


    def _calc_start_exploit(self, data, req, timer):
        """开始进行开采的逻辑
        """
        user = data.user.get(True)
        resource = data.resource.get()
        resource.update_current_resource(timer.now)

        node_id = NodeInfo.generate_id(data.id, req.node.basic_id)
        node = data.node_list.get(node_id)

        work_heroes = [] #参与采集的英雄
        for basic_id in req.node.exploitation.hero_basic_ids:
            if basic_id == 0:
                work_heroes.append(None)
            else:
                hero_id = HeroInfo.generate_id(data.id, basic_id)
                hero = data.hero_list.get(hero_id)
                work_heroes.append(hero)

        #将参与研究的英雄从其他建筑物中移除，更新原有建筑的影响
        #不结算英雄经验 : 英雄经验由客户端周期性请求结算
        #WARNING : 在上一次请求到此时英雄驻守的经验不结算
        for hero in work_heroes:
            if hero is not None and hero.is_working_in_building():
                building = data.building_list.get(hero.place_id)
                defense = None
                if building.is_defense():
                    defense = data.defense_list.get(building.id)
                if not building_business.remove_garrison(
                        building, hero, resource, timer.now):
                    raise Exception("Reassign build hero error")

        #所有生效的内政科技
        interior_technologys = [tech for tech in data.technology_list.get_all(True)
                if tech.is_interior_technology() and not tech.is_upgrade]

        #离线开采事件的开采时间单独设置
        if node.is_exploit_offline():
            if (req.node.exploitation.total_time != OFFLINE_EXPLOIT_TIME_1
                    and req.node.exploitation.total_time != OFFLINE_EXPLOIT_TIME_2
                    and req.node.exploitation.total_time != OFFLINE_EXPLOIT_TIME_3):
                raise Exception("Exploitation total time error")
            else:
                node.set_exploit_total_time(req.node.exploitation.total_time)
                node.set_exploit_level(req.node.exploitation.level)

        if not exploitation_business.start_exploit_event(
                data, node, work_heroes, timer.now, interior_technologys):
            raise Exception("Start exploit failed")

        #compare.check_node(data, req.node, with_exploit = True)

        return DataBase().commit(data)


    def _start_exploit_succeed(self, data, req, timer):
        res = exploitation_pb2.ExploitRes()
        res.status = 0
        pack.pack_resource_info(data.resource.get(True), res.resource)
        response = res.SerializeToString()
        log = log_formater.output(data, "Start exploit succeed", req, res, timer.count_ms())
        logger.notice(log)
        return response


    def _start_exploit_failed(self, err, req, timer):
        logger.fatal("Start exploit failed[reason=%s]" % err)
        res = exploitation_pb2.ExploitRes()
        res.status = -1
        response = res.SerializeToString()
        logger.notice("Start exploit failed[user_id=%d][req=%s][res=%s][consume=%d]" %
                (timer.id, req, res, timer.count_ms()))
        return response


    def finish_exploit(self, user_id, request, force = False):
        timer = Timer(user_id)

        req = exploitation_pb2.ExploitReq()
        req.ParseFromString(request)

        defer = DataBase().get_data(user_id)
        defer.addCallback(self._calc_finish_exploit, req, timer, force)
        defer.addErrback(self._finish_exploit_failed, req, timer)
        return defer


    def _calc_finish_exploit(self, data, req, timer, force):
        """结束开采
        """
        res = exploitation_pb2.ExploitRes()
        res.status = 0

        node_basic_id = req.node.basic_id
        node_id = NodeInfo.generate_id(data.id, node_basic_id)
        node = data.node_list.get(node_id)

        change_nodes = []
        new_items = []
        new_mails = []

        ret = Ret()
        if not exploitation_business.finish_exploit_event(
                data, node, timer.now, timer.now, change_nodes, new_items, new_mails, force, ret):
            if ret.get() == 'NOT_EXPLOITING':
                res.ret = exploitation_pb2.ExploitRes.NOT_EXPLOITING
                pack.pack_node_info(data, node, res.node, timer.now)
                return self._finish_exploit_succeed(data, req, res, timer)
            elif ret.get() == 'CANNT_FINISH':
                res.ret = exploitation_pb2.ExploitRes.CANNT_FINISH
                pack.pack_node_info(data, node, res.node, timer.now)
                return self._finish_exploit_succeed(data, req, res, timer)
            else:
                raise Exception("Finish exploit failed")

        resource = data.resource.get(True)
        assert len(new_mails) == 1
        mail = new_mails[0]
        res = self._pack_exploit_response(new_items, resource, mail, timer.now)

        defer = DataBase().commit(data)
        defer.addCallback(self._finish_exploit_succeed, req, res, timer)
        return defer


    def _pack_exploit_response(self, new_items, resource, mail, now):
        """打包开采响应
        """
        res = exploitation_pb2.ExploitRes()
        res.status = 0
        res.ret = exploitation_pb2.ExploitRes.OK

        pack.pack_resource_info(resource, res.resource)
        for (basic_id, num) in new_items:
            message_item = res.items.add()
            message_item.basic_id = basic_id
            message_item.num = num
        pack.pack_mail_info(mail, res.mail, now)

        return res


    def _finish_exploit_succeed(self, data, req, res, timer):
        response = res.SerializeToString()
        log = log_formater.output(data, "Finish exploit succeed", req, res, timer.count_ms())
        logger.notice(log)
        return response


    def _finish_exploit_failed(self, err, req, timer):
        logger.fatal("Finish exploit failed[reason=%s]" % err)
        res = exploitation_pb2.ExploitRes()
        res.status = -1
        response = res.SerializeToString()
        logger.notice("Finish exploit failed[user_id=%d][req=%s][res=%s][consume=%d]" %
                (timer.id, req, res, timer.count_ms()))
        return response


    def cancel_exploit(self, user_id, request):
        """取消采集
        相当于强制的完成了采集，获得部分资源和奖励
        """
        return self.finish_exploit(user_id, request, True)


