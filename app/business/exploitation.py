#coding:utf8
"""
Created on 2015-10-28
@Author: jiangtaoran(jiangtaoran@ice-time.cn)
@Brief : 世界地图资源相关逻辑
        1 资源采集
        2 资源等级提升
        3 开采随机事件逻辑（征税/屯田/采矿/金矿）
"""

from utils import logger
from utils import utils
from utils.ret import Ret
from datalib.data_loader import data_loader
from app.data.map import MapGraph
from app.data.node import NodeInfo
from app.core import reward as reward_module
from app.business import mail as mail_business
from app.business import hero as hero_business
from app.business import item as item_business
from app.business import map as map_business
from app import log_formater


def gather(data, nodes, new_items, now):
    """进行资源采集
    """
    resource = data.resource.get()
    resource.update_current_resource(now)

    for node in nodes:
        if not node.is_able_to_gather(now):
            return True    #为避免网络失败请求重复发，此处返回true 

        (money, food, item_count) = node.gather(now)
        resource.gain_money(money)
        resource.gain_food(food)
        gain_items = []
        if item_count > 0:
            gain_items = reward_module.random_exploit_material(
                    node.exploit_level, item_count)
            item_business.gain_item(data, gain_items, "gather item", log_formater.GATHER)

        new_items.extend(gain_items)
    
    return True


def finish_upgrade_event(data, node, now, use_gold = 0):
    """进行升级关键事件
    1 启动升级事件
    2 关键节点升一级
    3 结束随机事件，获得功勋值
    """
    #节点上必须有合法的升级随机事件
    if node.event_type != NodeInfo.EVENT_TYPE_UPGRADE:
        logger.warning("Wrong event[type=%d]" % node.event_type)
        return False
    if not node.launch_event(now):
        return False

    if not map_business.upgrade_key_node(data, node, now, use_gold):
        return False

    #获得成就值 和关键点等级相关
    resource = data.resource.get()
    resource.update_current_resource(now)
    ac_base = data_loader.LuckyEventBasicInfo_dict[node.event_type].achievementBase
    ac_coe = data_loader.LuckyEventBasicInfo_dict[node.event_type].achievementCoefficient
    achievement = ac_base + ac_coe * (node.level - 1)
    resource.gain_achievement(achievement)

    return node.finish_event(now)


def arise_gold_event(data, node, now, **kwargs):
    """出现金矿事件
    1 附属点变活跃
    2 附属点出现金矿资源信息
    """
    change_nodes = kwargs["change_nodes"]

    parent_basic_id = MapGraph().get_parent(node.basic_id)
    parent_id = NodeInfo.generate_id(data.id, parent_basic_id)
    parent = data.node_list.get(parent_id, True)

    map = data.map.get()
    user = data.user.get(True)
    node.respawn_dependency_with_gold(map, parent, now)

    return node.arise_event(NodeInfo.EVENT_TYPE_GOLD, now)


def clear_gold_event(data, node, now, **kwargs):
    """清除金矿事件
    1 附属点变为不活跃
    """
    change_nodes = kwargs["change_nodes"]

    map = data.map.get()
    node.reset_dependency(map)
    change_nodes.append(node)

    return node.clear_event()


def start_exploit_event(data, node, heroes, now, technologys = []):
    """启动开采事件（征税/屯田/采矿/金矿）
    派驻英雄，开始资源开采
    """
    #节点上必须有合法的随机事件
    if (node.event_type != NodeInfo.EVENT_TYPE_TAX and
            node.event_type != NodeInfo.EVENT_TYPE_FARM and
            node.event_type != NodeInfo.EVENT_TYPE_MINING and
            node.event_type != NodeInfo.EVENT_TYPE_GOLD and
            node.event_type != NodeInfo.EVENT_TYPE_SEARCH and
            node.event_type != NodeInfo.EVENT_TYPE_DEEP_MINING and
            node.event_type != NodeInfo.EVENT_TYPE_HERMIT):
        logger.warning("Wrong event[type=%d]" % node.event_type)
        return False
    if not node.launch_event(now):
        logger.warning("node launch event failed")
        return False

    if not node.is_able_to_exploit():
        logger.warning("Not able to exploit")
        return False

    #派驻英雄
    for hero in heroes:
        if hero is not None and not hero.assign_working_in_node(node.id, now):
            logger.warning("assign hero failed")
            return False

    if node.is_exploit_offline():
        #离线事件开采
        exploitation = data.exploitation.get()
        #判断hero num、research是否符合
        if not exploitation.is_heroes_satisfied(node, heroes, node.exploit_level):
            logger.warning("hero is not satisfied")
            return False

        #exploitation启动
        exploitation.start(node, now)

        return node.start_exploit(heroes, now, offline = True)
    else:
        #计算开采耗时
        consume_time = _calc_exploit_consume_time(node, heroes)

        #计算实际可开采量（科技提升）
        tech_basic_ids = [info.basic_id for info in technologys]
        exploit_reserve = _calc_exploit_reserves_with_technology(node, tech_basic_ids)

        #开始采集
        return node.start_exploit(heroes, now, consume_time, exploit_reserve)


def _calc_exploit_consume_time(node, heroes):
    """计算开采耗时
    英雄可以减少开采时间
    """
    time = node.exploit_total_time
    level = node.exploit_level
    total_reduce_time = 0
    for hero in heroes:
        if hero is None:
            continue

        ratio = _calc_time_reduce_by_hero(hero, level)
        total_reduce_time += utils.floor_to_int(time * ratio)

    logger.debug("calc node exploit time[node basic id=%d]"
            "[exploit type=%d][exploit level=%d][base time=%d][reduce time=%d]" %
            (node.basic_id, node.exploit_type, node.exploit_level,
                time, total_reduce_time))
    time -= total_reduce_time
    return int(time)


def _calc_exploit_reserves_with_technology(node, technology_basic_ids):
    """计算内政科技带来的可开采量提升
    """
    exploit_reserve_base = node.exploit_reserve
    addition = 0
    if node.is_exploit_money():
        for basic_id in technology_basic_ids:
            increase = (data_loader.InteriorTechnologyBasicInfo_dict[
                basic_id].interiorAttributeIncrease.bigmapMoneyOutput)
            increase = increase/ 100.0
            addition += utils.floor_to_int(increase * exploit_reserve_base)

    elif node.is_exploit_food():
        for basic_id in technology_basic_ids:
            increase = (data_loader.InteriorTechnologyBasicInfo_dict[
                basic_id].interiorAttributeIncrease.bigmapFoodOutput)
            increase = increase/ 100.0
            addition += utils.floor_to_int(increase * exploit_reserve_base)

    #elif self.is_exploit_gold():
    #策划暂未配提升金矿产量的科技

    elif node.is_exploit_material():
        for basic_id in technology_basic_ids:
            increase = (data_loader.InteriorTechnologyBasicInfo_dict[
                basic_id].interiorAttributeIncrease.bigmapMaterialOutput)
            increase = increase/ 100.0
            addition += utils.floor_to_int(increase * exploit_reserve_base)

    return exploit_reserve_base + addition


def _calc_time_reduce_by_hero(hero, level):
    """计算英雄参与建造/升级，可以减少多少耗时
    Args:
        hero[HeroInfo]: 英雄的信息
        level[int]: 主公等级限制，参与计算而已
    Returns:
        减少的时间比例: [0-1]
    """
    N = hero.interior_score
    SN = data_loader.MonarchLevelBasicInfo_dict[level].sn
    # P = float(data_loader.OtherBasicInfo_dict["P_Exploit"].value)
    P = 0.2
    if N <= SN:
        return pow(float(N) / SN, 2) * P
    else:
        return (1 + (0.33 / P - 1) * (1 - float(SN) / N)) * P


def stop_exploit_event(data, node, now, **kwargs):
    """停止开采事件
    """
    change_nodes = kwargs["change_nodes"]
    end_time = kwargs["end_time"]
    new_items = kwargs["new_items"]
    new_mails = kwargs["new_mails"]
    force = True

    return finish_exploit_event(data, node, now,
            end_time, change_nodes, new_items, new_mails, force)


def arise_offline_exploit_event(data, node, now, **kwargs):
    """出现离线开采事件（探索废墟/秘矿/探访隐士）
    1 敌人关键点出现该事件
    """
    event_type = kwargs['event_type']
    user = data.user.get(True)
    
    if not map_business.respawn_enemy_key_node(data, node, now):
        return False

    if not node.arise_event(event_type, now):
        return False

    exploitation = data.exploitation.get()
    if not exploitation.arise(node, now):
        return False

    if event_type == NodeInfo.EVENT_TYPE_SEARCH:
        node.set_exploit_level(exploitation.search_level)
    elif event_type == NodeInfo.EVENT_TYPE_DEEP_MINING:
        node.set_exploit_level(exploitation.deep_mining_level)
    elif event_type == NodeInfo.EVENT_TYPE_HERMIT:
        node.set_exploit_level(exploitation.hermit_level)

    return True


def clear_offline_exploit_event(data, node, now, **kwargs):
    """离线开采事件消失
    """
    change_nodes = kwargs['change_nodes']

    if not node.clear_event():
        return False

    exploitation = data.exploitation.get()
    if not exploitation.clear(node, now):
        return False

    if not map_business.close_offline_exploit_key_node(data, node, change_nodes):
        return False

    return True



def finish_exploit_event(data, node, now, end_time, change_nodes,
        new_items, new_mails, force = True, ret = Ret()):
    """
    结束开采事件
    1 结算资源、物品奖励
    2 结算英雄经验
    3 将相关信息填充进邮件
    Args:
        data[UserData]
        node[NodeInfo]: 节点信息
        end_time[int]: 结束的时间戳
        new_items[list(basic_id, num) out]
        new_mails[list(MailInfo) out]
        now[int]: 当前时间戳
        force[bool]: 是否强制结束
    """
    user = data.user.get(True)
    resource = data.resource.get()

    #节点上必须有合法的随机事件
    if (node.event_type != NodeInfo.EVENT_TYPE_TAX and
            node.event_type != NodeInfo.EVENT_TYPE_FARM and
            node.event_type != NodeInfo.EVENT_TYPE_MINING and
            node.event_type != NodeInfo.EVENT_TYPE_GOLD and
            node.event_type != NodeInfo.EVENT_TYPE_SEARCH and
            node.event_type != NodeInfo.EVENT_TYPE_DEEP_MINING and
            node.event_type != NodeInfo.EVENT_TYPE_HERMIT):
        logger.warning("Wrong event[type=%d]" % node.event_type)
        ret.setup("NOT_EXPLOITING")
        return False

    if not node.is_able_to_finish_exploit(end_time, force, ret):
        logger.warning("Not able to finish exploit")
        return False

    is_offline = False
    if node.is_exploit_offline():
        is_offline = True
    
    gain_items = []
    if not is_offline:
        #结算资源点资源采集
        resource.update_current_resource(now)
        original_gold = resource.gold
        (money, food, gold, material_count) = node.calc_exploit_income(end_time)
        resource.gain_money(money)
        resource.gain_food(food)
        resource.gain_gold(gold)
        log = log_formater.output_gold(data, gold, log_formater.EXPLOIT_GOLD,
                "Gain gold from exploit", before_gold = original_gold)
        logger.notice(log)

        if material_count > 0:
            gain_items = reward_module.random_exploit_material(
                    node.exploit_level, material_count)
    else:
        money = 0
        food = 0
        gold = 0

    #采集随机物品奖励
    if is_offline:
        #离线开采奖励物品个数
        exploitation = data.exploitation.get()
        (reward_level, reward_num) = exploitation.get_offline_exploit_reward(node, now)
        reward_items = reward_module.random_exploit_offline(node.event_type, reward_level, reward_num)
    else:
        progress = node.get_exploit_progress(end_time)
        reward_items = reward_module.random_exploit_gift(node.exploit_level, progress)
    gain_items.extend(reward_items)

    if not item_business.gain_item(data, gain_items, "exploit reward", log_formater.EXPLOIT_REWARD):
        logger.warning("Merge reward item failed")
        return False

    new_items.extend(gain_items)

    #如果开采正常结束，获取成就值
    if node.is_exploit_over(end_time):
        ac_base = data_loader.LuckyEventBasicInfo_dict[node.event_type].achievementBase
        ac_coe = data_loader.LuckyEventBasicInfo_dict[node.event_type].achievementCoefficient
        achievement = ac_base + ac_coe * node.level
        resource.gain_achievement(achievement)

    if is_offline:
        exploitation = data.exploitation.get()
        exploitation.finish(node, now)

    #采集完成邮件
    mail = mail_business.create_exploitation_mail(data, node.basic_id, end_time)
    new_mails.append(mail)
    mail.attach_reward(money, food, gold, gain_items)
    mail.attach_node_info(node)

    #移除英雄，结算经验
    work_heroes = [] #参与开采的英雄
    work_heroes_id = node.get_exploit_hero()
    for hero_id in work_heroes_id:
        if hero_id == 0:
            work_heroes.append(None)
        else:
            hero = data.hero_list.get(hero_id)
            work_heroes.append(hero)
    if not _reclaim_exploit_hero(data, node, user, work_heroes, end_time, now):
        return False

    if not node.finish_exploit(work_heroes, is_offline):
        return False

    #统计信息
    trainer = data.trainer.get()
    trainer.add_daily_finish_event_num(node.event_type, 1)

    if not node.finish_event(now, overtime = True):
        return False

    
    #金矿资源在采集完成后消失
    if node.is_exploit_gold():
        map = data.map.get()
        node.reset_dependency(map)
        change_nodes.append(node)
     
    if is_offline:
        node.clear_key_node()
        change_nodes.append(node)

    return True


def _reclaim_exploit_hero(data, node, user, heroes, end_time, now):
    """
    回收采集英雄，结算英雄经验
    """
    #如果采集中断，英雄也只会获得到到当前时间为止的经验
    end_time = min(node.exploit_start_time + node.exploit_total_time, end_time)
    exp_per_hour = data_loader.MonarchLevelBasicInfo_dict[user.level].exploitExpPerHour

    for hero in heroes:
        if hero is None:
            continue

        if not hero_business.level_upgrade_by_working(
                data, hero, exp_per_hour, end_time, now):
            logger.warning("Hero upgrade failed[hero basic id=%d]" % hero.basic_id)
            return False

    #英雄结束工作
    for hero in heroes:
        if hero is not None and not hero.finish_working():
            return False

    return True

